<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Single Molecule Tracking Analysis Documentation: SMT.SMT_Analysis_BP.helpers.clusterMethods.blob_detection.blob_detection Class Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../clipboard.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Single Molecule Tracking Analysis Documentation
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="../../d4/d20/namespace_s_m_t.html">SMT</a></li><li class="navelem"><a class="el" href="../../d3/d2c/namespace_s_m_t_1_1_s_m_t___analysis___b_p.html">SMT_Analysis_BP</a></li><li class="navelem"><a class="el" href="../../d8/d53/namespace_s_m_t_1_1_s_m_t___analysis___b_p_1_1helpers.html">helpers</a></li><li class="navelem"><a class="el" href="../../db/d22/namespace_s_m_t_1_1_s_m_t___analysis___b_p_1_1helpers_1_1cluster_methods.html">clusterMethods</a></li><li class="navelem"><a class="el" href="../../dc/dba/namespace_s_m_t_1_1_s_m_t___analysis___b_p_1_1helpers_1_1cluster_methods_1_1blob__detection.html">blob_detection</a></li><li class="navelem"><a class="el" href="../../db/d80/class_s_m_t_1_1_s_m_t___analysis___b_p_1_1helpers_1_1cluster_methods_1_1blob__detection_1_1blob__detection.html">blob_detection</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="../../db/d30/class_s_m_t_1_1_s_m_t___analysis___b_p_1_1helpers_1_1cluster_methods_1_1blob__detection_1_1blob__detection-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">SMT.SMT_Analysis_BP.helpers.clusterMethods.blob_detection.blob_detection Class Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aaa7a093282dc7a736ac32304b7018a3d" id="r_aaa7a093282dc7a736ac32304b7018a3d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaa7a093282dc7a736ac32304b7018a3d">__init__</a> (self, path, <a class="el" href="#af52aef5330d2d5b9840d3c34825d4117">median</a>=False, <a class="el" href="#af1eb266fb927d9b9460724e7c9b2ab62">threshold</a>=0.0005, <a class="el" href="#aa29a8bc04908b8ceaccee0f44263c38c">min_sigma</a>=1.0, <a class="el" href="#ae2e91f5642b885d2648465cd531547e6">max_sigma</a>=1.5, <a class="el" href="#ad1eadf3749cdc54b10e773587304d743">num_sigma</a>=500, <a class="el" href="#a5b73ffe9cf97ef25dfb492eb87f27467">overlap</a>=1., logscale=False, <a class="el" href="#ab7495ad775ceee0ba3d97d5634c8337b">verbose</a>=False, exclude_border=False)</td></tr>
<tr class="separator:aaa7a093282dc7a736ac32304b7018a3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad769c71268791fcf7b416f4df48b35f" id="r_aad769c71268791fcf7b416f4df48b35f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aad769c71268791fcf7b416f4df48b35f">open_file</a> (self)</td></tr>
<tr class="separator:aad769c71268791fcf7b416f4df48b35f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e50f64956ff8661467be7ddf0e18bba" id="r_a4e50f64956ff8661467be7ddf0e18bba"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4e50f64956ff8661467be7ddf0e18bba">detection</a> (self, type='skimage', **kwargs)</td></tr>
<tr class="separator:a4e50f64956ff8661467be7ddf0e18bba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67dee406055f2f9286cbb93c86dd343d" id="r_a67dee406055f2f9286cbb93c86dd343d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a67dee406055f2f9286cbb93c86dd343d">blob_logv2</a> (self, image, <a class="el" href="#aa29a8bc04908b8ceaccee0f44263c38c">min_sigma</a>=1, <a class="el" href="#ae2e91f5642b885d2648465cd531547e6">max_sigma</a>=50, <a class="el" href="#ad1eadf3749cdc54b10e773587304d743">num_sigma</a>=10, <a class="el" href="#af1eb266fb927d9b9460724e7c9b2ab62">threshold</a>=.2, <a class="el" href="#a5b73ffe9cf97ef25dfb492eb87f27467">overlap</a>=.5, <a class="el" href="#a46af073894ea8ae78fe8b892b8a97129">log_scale</a>=False, *, exclude_border=False, **kwargs)</td></tr>
<tr class="separator:a67dee406055f2f9286cbb93c86dd343d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e52846754deee540cc01a134ed370f8" id="r_a7e52846754deee540cc01a134ed370f8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7e52846754deee540cc01a134ed370f8">initalize_2dgaus</a> (self, **kwargs)</td></tr>
<tr class="separator:a7e52846754deee540cc01a134ed370f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a8840955ae78eea3a0b5d48b636e7c649" id="r_a8840955ae78eea3a0b5d48b636e7c649"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8840955ae78eea3a0b5d48b636e7c649">img</a></td></tr>
<tr class="separator:a8840955ae78eea3a0b5d48b636e7c649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af52aef5330d2d5b9840d3c34825d4117" id="r_af52aef5330d2d5b9840d3c34825d4117"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af52aef5330d2d5b9840d3c34825d4117">median</a></td></tr>
<tr class="separator:af52aef5330d2d5b9840d3c34825d4117"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1eb266fb927d9b9460724e7c9b2ab62" id="r_af1eb266fb927d9b9460724e7c9b2ab62"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af1eb266fb927d9b9460724e7c9b2ab62">threshold</a></td></tr>
<tr class="separator:af1eb266fb927d9b9460724e7c9b2ab62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa29a8bc04908b8ceaccee0f44263c38c" id="r_aa29a8bc04908b8ceaccee0f44263c38c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa29a8bc04908b8ceaccee0f44263c38c">min_sigma</a></td></tr>
<tr class="separator:aa29a8bc04908b8ceaccee0f44263c38c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2e91f5642b885d2648465cd531547e6" id="r_ae2e91f5642b885d2648465cd531547e6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae2e91f5642b885d2648465cd531547e6">max_sigma</a></td></tr>
<tr class="separator:ae2e91f5642b885d2648465cd531547e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1eadf3749cdc54b10e773587304d743" id="r_ad1eadf3749cdc54b10e773587304d743"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad1eadf3749cdc54b10e773587304d743">num_sigma</a></td></tr>
<tr class="separator:ad1eadf3749cdc54b10e773587304d743"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b73ffe9cf97ef25dfb492eb87f27467" id="r_a5b73ffe9cf97ef25dfb492eb87f27467"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5b73ffe9cf97ef25dfb492eb87f27467">overlap</a></td></tr>
<tr class="separator:a5b73ffe9cf97ef25dfb492eb87f27467"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46af073894ea8ae78fe8b892b8a97129" id="r_a46af073894ea8ae78fe8b892b8a97129"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a46af073894ea8ae78fe8b892b8a97129">log_scale</a></td></tr>
<tr class="separator:a46af073894ea8ae78fe8b892b8a97129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad78f70c6f8b5aab52bf6c39e22744f6a" id="r_ad78f70c6f8b5aab52bf6c39e22744f6a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad78f70c6f8b5aab52bf6c39e22744f6a">median_filter_size</a></td></tr>
<tr class="separator:ad78f70c6f8b5aab52bf6c39e22744f6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b1230877bf36c4ad2b5562b5d174f86" id="r_a3b1230877bf36c4ad2b5562b5d174f86"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3b1230877bf36c4ad2b5562b5d174f86">fitting_parameters</a></td></tr>
<tr class="separator:a3b1230877bf36c4ad2b5562b5d174f86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7495ad775ceee0ba3d97d5634c8337b" id="r_ab7495ad775ceee0ba3d97d5634c8337b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab7495ad775ceee0ba3d97d5634c8337b">verbose</a></td></tr>
<tr class="separator:ab7495ad775ceee0ba3d97d5634c8337b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:aa64b2eed7f4b5e85b9a95a0268dd7c66" id="r_aa64b2eed7f4b5e85b9a95a0268dd7c66"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa64b2eed7f4b5e85b9a95a0268dd7c66">_update_fitting_parameters</a> (self, kwargs={})</td></tr>
<tr class="separator:aa64b2eed7f4b5e85b9a95a0268dd7c66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02dbfd3e63ed5e85ba96695f7e146a85" id="r_a02dbfd3e63ed5e85ba96695f7e146a85"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a02dbfd3e63ed5e85ba96695f7e146a85">_prune_blobs</a> (self, blobs_array, <a class="el" href="#a5b73ffe9cf97ef25dfb492eb87f27467">overlap</a>, *, sigma_dim=1, **kwargs)</td></tr>
<tr class="separator:a02dbfd3e63ed5e85ba96695f7e146a85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaec83c0de2c0ab90918aede04a93be69" id="r_aaec83c0de2c0ab90918aede04a93be69"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaec83c0de2c0ab90918aede04a93be69">_update_blob_estimate</a> (self, blobs_pruned, fit_object, radius_func=None)</td></tr>
<tr class="separator:aaec83c0de2c0ab90918aede04a93be69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5d44847d8e1a8ea15aedfdbae353091" id="r_af5d44847d8e1a8ea15aedfdbae353091"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af5d44847d8e1a8ea15aedfdbae353091">_create_mask</a> (self, <a class="el" href="#a8840955ae78eea3a0b5d48b636e7c649">img</a>, coords, size, sigma_indx)</td></tr>
<tr class="separator:af5d44847d8e1a8ea15aedfdbae353091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeca2f2b945ad78036f5011c7f53efbfb" id="r_aeca2f2b945ad78036f5011c7f53efbfb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeca2f2b945ad78036f5011c7f53efbfb">_gaussian_mesh_helper</a> (self, mesh_2d, initial_xy, sub_arr=[3, 3])</td></tr>
<tr class="separator:aeca2f2b945ad78036f5011c7f53efbfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Parameters TODO
----------
Path : string
    Full path of the image to be read
median : bool
    if true apply a median filter to the image before blog detection
threshold : float
    threshold for the blob detection
min_sigma : float
    Minimum value of the gaussian sigma for the blobs
max_sigma : float
    Maximum value of the gaussian sigma for the blobs
num_sigma : int
    Eqidistant values between min_sigma and max_sigma to consider
overlap : float
    Allowed overlap of identified blobs. If 1, full overlap is allowed

Methods TODO
-------
open_file()
    opens the file and applied media filter if true
    retuns an array
detection()
    applies blob detection using np.blob_log
    returns array of blob attributes or dictionary of blob attributes
Notes
-----
theory: https://www.cse.psu.edu/~rtc12/CSE586/lectures/featureExtractionPart2_6pp.pdf
https://cvgl.stanford.edu/teaching/cs231a_winter1415/lecture/lecture10_detector_descriptors_2015_notes.pdf
</pre> </div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aaa7a093282dc7a736ac32304b7018a3d" name="aaa7a093282dc7a736ac32304b7018a3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa7a093282dc7a736ac32304b7018a3d">&#9670;&#160;</a></span>__init__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SMT.SMT_Analysis_BP.helpers.clusterMethods.blob_detection.blob_detection.__init__ </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>path</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>median</em></span><span class="paramdefsep"> = </span><span class="paramdefval">False</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>threshold</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.0005</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>min_sigma</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1.0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>max_sigma</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1.5</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>num_sigma</em></span><span class="paramdefsep"> = </span><span class="paramdefval">500</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>overlap</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1.</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>logscale</em></span><span class="paramdefsep"> = </span><span class="paramdefval">False</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>verbose</em></span><span class="paramdefsep"> = </span><span class="paramdefval">False</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>exclude_border</em></span><span class="paramdefsep"> = </span><span class="paramdefval">False</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Initilizes the class object with the parameters for the blob detection

Parameters:
-----------
Path : string or 2d array
    Full path of the image to be read or the 2d array of the image
median : bool
    if true apply a median filter to the image before blog detection
threshold : float
    threshold for the blob detection
min_sigma : float
    Minimum value of the gaussian sigma for the blobs
max_sigma : float
    Maximum value of the gaussian sigma for the blobs
num_sigma : int
    Eqidistant values between min_sigma and max_sigma to consider
overlap : float
    Allowed overlap of identified blobs. If 1, full overlap is allowed
logscale : bool
    if True, use a log scale for the sigma values
verbose : bool
    if True, return out the parameters used for the blob detection and fitting
exclude_border : tuple of ints, int, or False, optional, Default is False.
    If tuple of ints, the length of the tuple must match the input array's
    dimensionality.  Each element of the tuple will exclude peaks from
    within `exclude_border`-pixels of the border of the image along that
    dimension.
    If nonzero int, `exclude_border` excludes peaks from within
    `exclude_border`-pixels of the border of the image.
    If zero or False, peaks are identified regardless of their
    distance from the border. See method "blob_logv2" for more info
Notes:
------
1. The blob detection is done using the skimage.blob_log() function or a custom function. The custom function is a modified version of the skimage.blob_log() function. Named blob_logv2()
2. To use the custom function, call the method detection() with the argument type='bp' else the default is 'skimage'
</pre> 
</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="af5d44847d8e1a8ea15aedfdbae353091" name="af5d44847d8e1a8ea15aedfdbae353091"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5d44847d8e1a8ea15aedfdbae353091">&#9670;&#160;</a></span>_create_mask()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SMT.SMT_Analysis_BP.helpers.clusterMethods.blob_detection.blob_detection._create_mask </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>img</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>coords</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>sigma_indx</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">mask of the image at the center point of the pixel coordinate. Also applies the fits
TODO make this modular and seperate the mask creation and the fitting to allow better user control.

Parameters
----------
img : 2D array
    array defining the image 
coords : (N,3) array
    array defining the [x,y,radius] of the blobs 
size : int
    size of the square box around coord[:2] in which to fit 
sigma_indx : N array
    array defining the index of the sigmas used for each blob in coords

Returns
-------
lmfit.minimize.fit objects in a list: [object, object, ... ]
    the fit objects created by lmfit.minizie for each coord. 

Raises
------
TypeError
    "size needs to an integer value"
Exception
    "simga_indx needs to be same shape as coords"
</pre> 
</div>
</div>
<a id="aeca2f2b945ad78036f5011c7f53efbfb" name="aeca2f2b945ad78036f5011c7f53efbfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeca2f2b945ad78036f5011c7f53efbfb">&#9670;&#160;</a></span>_gaussian_mesh_helper()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SMT.SMT_Analysis_BP.helpers.clusterMethods.blob_detection.blob_detection._gaussian_mesh_helper </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>mesh_2d</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>initial_xy</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>sub_arr</em></span><span class="paramdefsep"> = </span><span class="paramdefval">[3,3]</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">takes a 2d_mesh (image data) and a bounding box to return a list of (x,y,z) in that bounding box
box is implimented from the center point of the pixel. this function works similar to Analysis_functions.subarray2D()

Parameters
----------
mesh_2d : 2D array
    image data in 2D array format
initial_xy : tuple or array-like of len 2
    [x,y] coordinate of the center point around which to create the subarray
sub_arr : tuple or 1D array, optional
    the grid size from the center to create the mesh, by default [3,3]

Returns
-------
1D list
    array containing: 
        x,y: the x,y coordinates of the meshgrid
        mesh_view: subarray defined from the original image
        centers: centers of the mesh
</pre> 
</div>
</div>
<a id="a02dbfd3e63ed5e85ba96695f7e146a85" name="a02dbfd3e63ed5e85ba96695f7e146a85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02dbfd3e63ed5e85ba96695f7e146a85">&#9670;&#160;</a></span>_prune_blobs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SMT.SMT_Analysis_BP.helpers.clusterMethods.blob_detection.blob_detection._prune_blobs </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>blobs_array</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>overlap</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>sigma_dim</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**</td>          <td class="paramname"><span class="paramname"><em>kwargs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Eliminated blobs with area overlap. UPDATED: compared to the skimage implimentation this prunes based on the 
maximum value of the laplacian of the blobs rather than if the blob is bigger or not.

Parameters
----------
blobs_array : ndarray
    A 2d array with each row representing 3 (or 4) values,
    ``(row, col, sigma)`` or ``(pln, row, col, sigma)`` in 3D,
    where ``(row, col)`` (``(pln, row, col)``) are coordinates of the blob
    and ``sigma`` is the standard deviation of the Gaussian kernel which
    detected the blob.
    This array must not have a dimension of size 0.
overlap : float
    A value between 0 and 1. If the fraction of area overlapping for 2
    blobs is greater than `overlap` the smaller blob is eliminated.
sigma_dim : int, optional
    The number of columns in ``blobs_array`` corresponding to sigmas rather
    than positions.

KWARGS
------
max_lap: N-array
    array of values for each blob indicating the max value of the laplacian that created it
sigma_indx: n-array
    array of indexes of the sigmas for the blob, this is just inputted for conveniecne in later calulations. Not used here

Returns
-------
A : ndarray
    `array` with overlapping blobs removed.

Notes
-----
Example: blob1 = [100,100,3], blob2 = [101,101,3]
max_lap = [1,2]. If the overlap is larger than the threshold used then blob2 is choosen because it produces a larger max_lap
</pre> 
</div>
</div>
<a id="aaec83c0de2c0ab90918aede04a93be69" name="aaec83c0de2c0ab90918aede04a93be69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaec83c0de2c0ab90918aede04a93be69">&#9670;&#160;</a></span>_update_blob_estimate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SMT.SMT_Analysis_BP.helpers.clusterMethods.blob_detection.blob_detection._update_blob_estimate </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>blobs_pruned</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>fit_object</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>radius_func</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Using fitted parameters update the esimates of the centroid and sigmas for blob fit

Parameters
----------
blobs_pruned: (ndarry) 
    output from self._prune_blobs()
fit_object: (lmfit.minimize.fit object)
    instances of the .fit object from lmfit's minimize
radius_func: (functional, optional)
    Which function to use to remap anisotropic sigmas into isotropic sigma. Defaults to None.


Returns
-------
(N,3) array 
    first output is [(x,y,s),...] of the blobs updates
(N,3) array 
    second is the original blobs inputed for comparison
</pre> 
</div>
</div>
<a id="aa64b2eed7f4b5e85b9a95a0268dd7c66" name="aa64b2eed7f4b5e85b9a95a0268dd7c66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa64b2eed7f4b5e85b9a95a0268dd7c66">&#9670;&#160;</a></span>_update_fitting_parameters()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SMT.SMT_Analysis_BP.helpers.clusterMethods.blob_detection.blob_detection._update_fitting_parameters </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>kwargs</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Updates the fitting_parameters to be used in each iteration of this class object

Kwargs
------
mask_size: int
    when fitting the image with a function this is size of square round a reference point to use for fit
residual_func: functional
    function to use when defining the residuals for the fitting
fit_method: string, default 'least squares'
    method of the fitting to use 
radius_func: functional, default numpy.mean
    function to use as a method to take two sigams and convert to one radius 
plot_fit: bool
    if True, plots each fit with the fit statistics
centroid_range: int or float-like
    controls the bounds on the fit for the centroid (x,y). Ie: the min fit is x-centroid_range, and max is x+centroid_range
    same for y.
sigma_range: int or float-like
    controls the bounds on the fit for the sigmas (s_x,s_y). Ie: the min fit is s_x-sigma_range, and max is s_x+sigma_range
    same for y.
fitting_image: string
    if "Original" use the original image to fit function
    else use the Laplacian image created with the sigma that maximized the laplacian

Notes
-----
Some of these expect a certain type to work. This is not fully coded yet and might break if you give inputs which dont make sense
to it.
</pre> 
</div>
</div>
<a id="a67dee406055f2f9286cbb93c86dd343d" name="a67dee406055f2f9286cbb93c86dd343d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67dee406055f2f9286cbb93c86dd343d">&#9670;&#160;</a></span>blob_logv2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SMT.SMT_Analysis_BP.helpers.clusterMethods.blob_detection.blob_detection.blob_logv2 </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>image</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>min_sigma</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>max_sigma</em></span><span class="paramdefsep"> = </span><span class="paramdefval">50</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>num_sigma</em></span><span class="paramdefsep"> = </span><span class="paramdefval">10</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>threshold</em></span><span class="paramdefsep"> = </span><span class="paramdefval">.2</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>overlap</em></span><span class="paramdefsep"> = </span><span class="paramdefval">.5</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>log_scale</em></span><span class="paramdefsep"> = </span><span class="paramdefval">False</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>exclude_border</em></span><span class="paramdefsep"> = </span><span class="paramdefval">False</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**</td>          <td class="paramname"><span class="paramname"><em>kwargs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Finds blobs in the given grayscale image. Adapted from the implimentation of skimage blob-log: 
https://scikit-image.org/docs/stable/auto_examples/features_detection/plot_blob.html

Blobs are found using the Laplacian of Gaussian (LoG) method [1]_.
For each blob found, the method returns its coordinates and the standard
deviation of the Gaussian kernel that detected the blob.

Parameters
----------
image : 2D or 3D ndarray
    Input grayscale image, blobs are assumed to be light on dark
    background (white on black).
min_sigma : scalar or sequence of scalars, optional
    the minimum standard deviation for Gaussian kernel. Keep this low to
    detect smaller blobs. The standard deviations of the Gaussian filter
    are given for each axis as a sequence, or as a single number, in
    which case it is equal for all axes.
max_sigma : scalar or sequence of scalars, optional
    The maximum standard deviation for Gaussian kernel. Keep this high to
    detect larger blobs. The standard deviations of the Gaussian filter
    are given for each axis as a sequence, or as a single number, in
    which case it is equal for all axes.
num_sigma : int, optional
    The number of intermediate values of standard deviations to consider
    between `min_sigma` and `max_sigma`.
threshold : float, optional.
    The absolute lower bound for scale space maxima. Local maxima smaller
    than thresh are ignored. Reduce this to detect blobs with less
    intensities.
overlap : float, optional
    A value between 0 and 1. If the area of two blobs overlaps by a
    fraction greater than `threshold`, the blob with the smaller maximum 
    laplacian value is eliminated. If set to 1, then all overlapping blobs
    are kept. 
log_scale : bool, optional
    If set intermediate values of standard deviations are interpolated
    using a logarithmic scale to the base `10`. If not, linear
    interpolation is used.
exclude_border : tuple of ints, int, or False, optional
    If tuple of ints, the length of the tuple must match the input array's
    dimensionality.  Each element of the tuple will exclude peaks from
    within `exclude_border`-pixels of the border of the image along that
    dimension.
    If nonzero int, `exclude_border` excludes peaks from within
    `exclude_border`-pixels of the border of the image.
    If zero or False, peaks are identified regardless of their
    distance from the border.

Returns
-------
A : (n, image.ndim + sigma) ndarray
    A 2d array with each row representing 2 coordinate values for a 2D
    image, and 3 coordinate values for a 3D image, plus the sigma(s) used.
    When a single sigma is passed, outputs are:
    ``(r, c, sigma)`` or ``(p, r, c, sigma)`` where ``(r, c)`` or
    ``(p, r, c)`` are coordinates of the blob and ``sigma`` is the standard
    deviation of the Gaussian kernel which detected the blob. When an
    anisotropic gaussian is used (sigmas per dimension), the detected sigma
    is returned for each dimension.

References
----------
.. [1] https://en.wikipedia.org/wiki/Blob_detection#The_Laplacian_of_Gaussian

Examples
--------
&gt;&gt;&gt; from skimage import data, feature, exposure
&gt;&gt;&gt; img = data.coins()
&gt;&gt;&gt; img = exposure.equalize_hist(img)  # improves detection
&gt;&gt;&gt; feature.blob_log(img, threshold = .3)
array([[124.        , 336.        ,  11.88888889],
    [198.        , 155.        ,  11.88888889],
    [194.        , 213.        ,  17.33333333],
    [121.        , 272.        ,  17.33333333],
    [263.        , 244.        ,  17.33333333],
    [194.        , 276.        ,  17.33333333],
    [266.        , 115.        ,  11.88888889],
    [128.        , 154.        ,  11.88888889],
    [260.        , 174.        ,  17.33333333],
    [198.        , 103.        ,  11.88888889],
    [126.        , 208.        ,  11.88888889],
    [127.        , 102.        ,  11.88888889],
    [263.        , 302.        ,  17.33333333],
    [197.        ,  44.        ,  11.88888889],
    [185.        , 344.        ,  17.33333333],
    [126.        ,  46.        ,  11.88888889],
    [113.        , 323.        ,   1.        ]])

Notes
-----
The radius of each blob is approximately :math:`\sqrt{2}\sigma` for
a 2-D image and :math:`\sqrt{3}\sigma` for a 3-D image.
</pre> 
</div>
</div>
<a id="a4e50f64956ff8661467be7ddf0e18bba" name="a4e50f64956ff8661467be7ddf0e18bba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e50f64956ff8661467be7ddf0e18bba">&#9670;&#160;</a></span>detection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SMT.SMT_Analysis_BP.helpers.clusterMethods.blob_detection.blob_detection.detection </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>type</em></span><span class="paramdefsep"> = </span><span class="paramdefval">'skimage'</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**</td>          <td class="paramname"><span class="paramname"><em>kwargs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Applies the blob_log scheme to detect blobs in an image using the parameters of this class object
Full list see __init__().__doc__

Parameters
----------
type: string
    if "bp" use the custom blob_logv2() elif "skimage" use the skimage implimentation of blob_log

Returns
-------
if verbose is True: return type is a dictionary
    returns a dictionary of the parameters used for the blob detection and fitting and the fitted objects
else: return type is a numpy array of size 3 tuples
    returns the scale space blobs found in the image

Notes:
------
1. For 2D images the blob radius estimate is the standard deviation of the gaussian fit to the image times sqrt(2) (see theory)
2. Scale fits are isotropic 
3. Fitted fits are anisotropic and are size 4 tuples with simga_x and sigma_y
</pre> 
</div>
</div>
<a id="a7e52846754deee540cc01a134ed370f8" name="a7e52846754deee540cc01a134ed370f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e52846754deee540cc01a134ed370f8">&#9670;&#160;</a></span>initalize_2dgaus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SMT.SMT_Analysis_BP.helpers.clusterMethods.blob_detection.blob_detection.initalize_2dgaus </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**</td>          <td class="paramname"><span class="paramname"><em>kwargs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">initalizes lmfit parameters

Returns
-------
Parameter() class object
    class object defining the parameters with bounds for the fit later on
</pre> 
</div>
</div>
<a id="aad769c71268791fcf7b416f4df48b35f" name="aad769c71268791fcf7b416f4df48b35f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad769c71268791fcf7b416f4df48b35f">&#9670;&#160;</a></span>open_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SMT.SMT_Analysis_BP.helpers.clusterMethods.blob_detection.blob_detection.open_file </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Opens and retuns array of the image data

Parameters
----------
self.img: string of a path or path object, or 2D image
    if path provided opens the file and reads in image data to apply filter or applies filter is self.img is 2D array
self.median: bool
    if True applies a median filter of size self.median_filter_size before returning 2D array
 

Returns
-------
array-like
    2D array of the image data
</pre> 
</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a3b1230877bf36c4ad2b5562b5d174f86" name="a3b1230877bf36c4ad2b5562b5d174f86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b1230877bf36c4ad2b5562b5d174f86">&#9670;&#160;</a></span>fitting_parameters</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SMT.SMT_Analysis_BP.helpers.clusterMethods.blob_detection.blob_detection.fitting_parameters</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8840955ae78eea3a0b5d48b636e7c649" name="a8840955ae78eea3a0b5d48b636e7c649"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8840955ae78eea3a0b5d48b636e7c649">&#9670;&#160;</a></span>img</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SMT.SMT_Analysis_BP.helpers.clusterMethods.blob_detection.blob_detection.img</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a46af073894ea8ae78fe8b892b8a97129" name="a46af073894ea8ae78fe8b892b8a97129"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46af073894ea8ae78fe8b892b8a97129">&#9670;&#160;</a></span>log_scale</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SMT.SMT_Analysis_BP.helpers.clusterMethods.blob_detection.blob_detection.log_scale</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae2e91f5642b885d2648465cd531547e6" name="ae2e91f5642b885d2648465cd531547e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2e91f5642b885d2648465cd531547e6">&#9670;&#160;</a></span>max_sigma</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SMT.SMT_Analysis_BP.helpers.clusterMethods.blob_detection.blob_detection.max_sigma</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af52aef5330d2d5b9840d3c34825d4117" name="af52aef5330d2d5b9840d3c34825d4117"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af52aef5330d2d5b9840d3c34825d4117">&#9670;&#160;</a></span>median</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SMT.SMT_Analysis_BP.helpers.clusterMethods.blob_detection.blob_detection.median</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad78f70c6f8b5aab52bf6c39e22744f6a" name="ad78f70c6f8b5aab52bf6c39e22744f6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad78f70c6f8b5aab52bf6c39e22744f6a">&#9670;&#160;</a></span>median_filter_size</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SMT.SMT_Analysis_BP.helpers.clusterMethods.blob_detection.blob_detection.median_filter_size</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa29a8bc04908b8ceaccee0f44263c38c" name="aa29a8bc04908b8ceaccee0f44263c38c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa29a8bc04908b8ceaccee0f44263c38c">&#9670;&#160;</a></span>min_sigma</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SMT.SMT_Analysis_BP.helpers.clusterMethods.blob_detection.blob_detection.min_sigma</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad1eadf3749cdc54b10e773587304d743" name="ad1eadf3749cdc54b10e773587304d743"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1eadf3749cdc54b10e773587304d743">&#9670;&#160;</a></span>num_sigma</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SMT.SMT_Analysis_BP.helpers.clusterMethods.blob_detection.blob_detection.num_sigma</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5b73ffe9cf97ef25dfb492eb87f27467" name="a5b73ffe9cf97ef25dfb492eb87f27467"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b73ffe9cf97ef25dfb492eb87f27467">&#9670;&#160;</a></span>overlap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SMT.SMT_Analysis_BP.helpers.clusterMethods.blob_detection.blob_detection.overlap</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af1eb266fb927d9b9460724e7c9b2ab62" name="af1eb266fb927d9b9460724e7c9b2ab62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1eb266fb927d9b9460724e7c9b2ab62">&#9670;&#160;</a></span>threshold</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SMT.SMT_Analysis_BP.helpers.clusterMethods.blob_detection.blob_detection.threshold</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab7495ad775ceee0ba3d97d5634c8337b" name="ab7495ad775ceee0ba3d97d5634c8337b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7495ad775ceee0ba3d97d5634c8337b">&#9670;&#160;</a></span>verbose</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SMT.SMT_Analysis_BP.helpers.clusterMethods.blob_detection.blob_detection.verbose</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/Users/baljyot/Documents/CODE/GitHub_t2/PHD/Baljyot_EXP_RPOC/Scripts/SMT/SMT_Analysis_BP/helpers/clusterMethods/<a class="el" href="../../df/d4b/blob__detection_8py.html">blob_detection.py</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.11.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
